var formats = require('./formats');

var zeroes = '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';

var spaces = '                                                                                              ';

var nines = '9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n';

function padNum(num, size) {
  var diff, string;
  if (num == null) {
    num = '';
  }
  string = num.toString();
  diff = size - string.length;
  if (diff > 0) {
    string = zeroes.slice(0, diff) + string;
  } else if (diff < 0) {
    string = string.slice(-size);
  }
  return string;
}

function padString(string, size) {
  var diff;
  if (string == null) {
    string = '';
  }
  diff = size - string.length;
  if (diff > 0) {
    string += spaces.slice(0, diff);
  } else if (diff < 0) {
    string = string.slice(0, size);
  }
  return string;
}

function outputFields(source, format) {
  var result = '';
  format.fields.forEach(function (field) {
    var value = source[field.name];
    var pad = field.numeric ? padNum : padString;
    result += pad(value, field.length);
  });
  return result + '\n';
}

function achFormatterTransform(ach) {
  var formattedOutput = '';

  formattedOutput += outputFields(ach.file, formats.fileHeader);

  ach.batches.forEach(function (batch) {
    formattedOutput += outputFields(batch, formats.batchHeader);
    var format = formats[batch.entryClassCode];
    
    batch.entries.forEach(function (entry) {
      formattedOutput += outputFields(entry, format.entry);
      
      if (entry.addenda != null) {
        formattedOutput += outputFields(entry.addenda, format.addenda);
      } else if (entry.addendas != null) {
        entry.addendas.forEach(function (addenda) {
          formattedOutput += outputFields(addenda, format.addenda);
        });
      }
    });

    formattedOutput += outputFields(batch.footer, formats.batchFooter);
  });

  formattedOutput += outputFields(ach.file.footer, formats.fileFooter);

  var linesNeeded = 10 - (ach.file.footer.lineCount % 10);
  for (var i = 0; i < linesNeeded; i++) {
    formattedOutput += nines;
  }

  return formattedOutput;
}

module.exports = achFormatterTransform;



/* // Generated by CoffeeScript 1.11.1
var AchFormatter, formats, nines, outputFields, padNum, padString, spaces, zeroes,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

formats = require('./formats');

zeroes = '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';

spaces = '                                                                                              ';

nines = '9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n';

padNum = function(num, size) {
  var diff, string;
  if (num == null) {
    num = '';
  }
  string = num.toString();
  diff = size - string.length;
  if (diff > 0) {
    string = zeroes.slice(0, diff) + string;
  } else if (diff < 0) {
    string = string.slice(-size);
  }
  return string;
};

padString = function(string, size) {
  var diff;
  if (string == null) {
    string = '';
  }
  diff = size - string.length;
  if (diff > 0) {
    string += spaces.slice(0, diff);
  } else if (diff < 0) {
    string = string.slice(0, size);
  }
  return string;
};

outputFields = function(source, format, push) {
  var field, i, j, len, pad, ref, value;
  i = 0;
  ref = format.fields;
  for (j = 0, len = ref.length; j < len; j++) {
    field = ref[j];
    value = source[field.name];
    pad = field.numeric ? padNum : padString;
    value = pad(value, field.length);
    push(value);
  }
  return push('\n');
};

module.exports = AchFormatter = (function(superClass) {
  extend(AchFormatter, superClass);

  function AchFormatter() {
    AchFormatter.__super__.constructor.call(this, {
      readableObjectMode: false,
      writableObjectMode: true
    });
    this.on('error', console.log.bind(console));
  }

  AchFormatter.prototype._transform = function(ach, _, done) {
    var addenda, batch, entry, format, i, j, k, l, len, len1, len2, linesNeeded, m, push, ref, ref1, ref2, ref3;
    push = this.push.bind(this);
    outputFields(ach.file, formats.fileHeader, push);
    ref = ach.batches;
    for (j = 0, len = ref.length; j < len; j++) {
      batch = ref[j];
      outputFields(batch, formats.batchHeader, push);
      format = formats[batch.entryClassCode];
      ref1 = batch.entries;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];
        outputFields(entry, format.entry, push);
        if (entry.addenda != null) {
          outputFields(entry.addenda, format.addenda, push);
        } else if (entry.addendas != null) {
          ref2 = entry.addendas;
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            addenda = ref2[l];
            outputFields(addenda(format.addenda, push));
          }
        }
      }
      outputFields(batch.footer, formats.batchFooter, push);
    }
    outputFields(ach.file.footer, formats.fileFooter, push);
    linesNeeded = 10 - (ach.file.footer.lineCount % 10);
    for (i = m = 1, ref3 = linesNeeded; 1 <= ref3 ? m <= ref3 : m >= ref3; i = 1 <= ref3 ? ++m : --m) {
      this.push(nines);
    }
    return done();
  };

  return AchFormatter;

})(require('stream').Transform);
 */