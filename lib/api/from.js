// Generated by CoffeeScript 1.11.1
var from, isEftObject, isStream, to;

isStream = require('./is-stream');

isEftObject = require('./is-eft-object');

transforms = require('../transforms');

create = require('./create');

to = require('./to');

module.exports = from = (options) => {
  if(options == null) throw new Error('options is required')

  if(typeof options === 'string'){

    try {
      JSON.parse(options)

      options = {
        format: 'json',
        source: options
      }
    } catch (error) {
      options = {
        format: 'ach',
        source: options
      }
    }
  }

  else if(typeof options === 'object') {
    // If the given object doesn't have required 
    // properties we assume they're passing an object to be converted
    if(!options.format || !options.source){
      options = {
        format: 'object',
        source: options
      }
    }
  }
  
  let { format, source } = options

  if(format === 'object'){

    // Check if source is in valid file format
    try {
      // When data from create fn the required data will be in object, if it's from another parsed type it will be in data
      // if not we will try to just grab the whole object & parse that
      let data = source.object || source.data || source
      let fromObj = {
        data: data,
        to: to
      }

      // if File data is in correct format we should be able to convert to ach File
      fromObj.to('ach')

      return fromObj 
    } catch (error) {
      throw new Error(`Failed to create ACH file from input`)
    }
  }

  let parser = transforms.getParser(format)

  if(!parser) throw new Error(`Not a valid format ${format}`)



  return {
    data: parser(source),
    to: to
  }

}

/* module.exports = from = function(options) {
  var From, errorProvider, source, transform;
  if (options == null) {
    options = {};
  }
  if ('string' === typeof options && transforms.getParser(options)) {
    options = {
      format: options,
      source: process.stdin
    };
  } else if (isStream(options)) {
    options = {
      format: 'ach',
      source: options
    };
  }
  from = {
    streams: []
  };
  if ((options != null ? options.source : void 0) != null) {
    from.streams.unshift(source = isStream(options.source) ? options.source : 'string' === typeof options.source ? strung(options.source) : isEftObject(options.source) ? objectable(options.source) : process.stdin);
  } else {
    from.streams.unshift(process.stdin);
  }
  if (options.format == null) {
    options.format = 'ach';
  }
  transform = transforms.getParser(options.format);
  if (transform == null) {
    return errorProvider = {
      error: 'invalid \'from\' format: ' + options.format,
      edit: function() {
        return this;
      },
      to: function() {
        return this;
      }
    };
  } else {
    from.streams.unshift(transform);
  }
  return From = {
    edit: edit.bind(from),
    to: to.bind(from),
    toObject: toObject.bind(from)
  };
}; */
